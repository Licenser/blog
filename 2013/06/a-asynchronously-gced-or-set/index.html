<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:title" content="A asynchronously GCed OR Set"><meta property="og:description" content="Following the article about Asynchronous garbage collection with CRDTs I experimented with implementing the concept. The OR Set is a very nice data structure for this since it's rather simple and so is it's garbage!
To garbage collect the OR Set we do the following, we take some of the elements of the remove set, and delete them from both the add and the remove set - this way we save the space for them and generate a new baseline."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/"><meta property="article:published_time" content="2013-06-13T00:00:00+00:00"><meta property="article:modified_time" content="2013-06-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A asynchronously GCed OR Set"><meta name=twitter:description content="Following the article about Asynchronous garbage collection with CRDTs I experimented with implementing the concept. The OR Set is a very nice data structure for this since it's rather simple and so is it's garbage!
To garbage collect the OR Set we do the following, we take some of the elements of the remove set, and delete them from both the add and the remove set - this way we save the space for them and generate a new baseline."><meta name=generator content="Hugo 0.62.2"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"A asynchronously GCed OR Set","url":"https:\/\/blog.licenser.net\/2013\/06\/a-asynchronously-gced-or-set\/","wordCount":"1227","datePublished":"2013-06-13T00:00:00+00:00","dateModified":"2013-06-13T00:00:00+00:00","author":{"@type":"Person","name":"Heinz N. Gies"}}</script><link rel=canonical href=https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/><title>A asynchronously GCed OR Set | Lice!</title><link href=https://blog.licenser.net/css/style.6da5c906cc7a8fbb93f31cd2316c5dbe3f19ac4aa6bfb066f1243045b8f6061e.css rel=stylesheet integrity="sha256-baXJBsx6j7uT8xzSMWxdvj8ZrEqmv7Bm8SQwRbj2Bh4=" crossorigin=anonymous><script defer src=https://blog.licenser.net/js/fontawesome.min.90e14c13cee52929ac33e1c21694a3cc95063a194eb22aad9f7976434e1a9125.js integrity="sha256-kOFME87lKSmsM+HCFpSjzJUGOhlOsiqtn3l2Q04akSU=" crossorigin=anonymous></script></head><body><div class=blog-masthead><div class=container><nav class="nav blog-nav"><a class=nav-link href=https://blog.licenser.net/>Home</a></nav></div></div><header class=blog-header><div class=container><h1 class=blog-title dir=auto><a href=https://blog.licenser.net/ rel=home>Lice!</a></h1><p class="lead blog-description" dir=auto>A collection of somewhat random thoughts.</p></div></header><div class=container><div class=row><div class="col-sm-8 blog-main"><article class=blog-post><header><h2 class=blog-post-title dir=auto><a href=https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/>A asynchronously GCed OR Set</a></h2><p class=blog-post-meta><time datetime=2013-06-13T00:00:00Z>2013-06-13</time> by Heinz N. Gies</p></header><p>Following the <a href=/blog/2013/06/11/asyncronous-garbage-collection-with-crdts/>article about Asynchronous garbage collection with CRDTs</a> I experimented with <a href=https://github.com/Licenser/ecrdt/blob/master/src/vorsetg.erl>implementing the concept</a>. The OR Set is a very nice data structure for this since it's rather simple and so is it's garbage!</p><p>To garbage collect the <a href=https://github.com/Licenser/ecrdt/blob/master/src/vorset.erl>OR Set</a> we do the following, we take some of the elements of the remove set, and delete them from both the add and the remove set - this way we save the space for them and generate a new baseline.</p><p>First step was to implement the data structure described to hold the collectable items, I call it a <a href=https://github.com/Licenser/ecrdt/blob/master/src/rot.erl>ROT</a> (Roughly Ordered Tree) it's a nice name for garbage related stuff ;) and it is treeish and mostly ordered.</p><p>The interface of the ROT is rather simple, Elements must be time tagged, in the form {Time, Element}. Where time must not be a clock, as long as the Erlang comparison operations work on it to give an order. Then it allows asking for full buckets, and removing buckets based on their hash value and newest message timestamp.</p><p>While the elements in a the OR set area already tagged with a timestamp, this timestamp records addition, not deletion so it would be misleading to use them since the ROT would think the remove happened when actually the addition happened and this would violate the rule that no event can travel back behind T100. As a result we'll have to double timestamp the removes - as in add a second when when it was removed.</p><p>So since the ROT has a very similar interface to a G Set (which implemented the remove set before) the change is trivial. <strong>Remove</strong>, <strong>GC</strong> and the <strong>merge</strong> function are more interesting.</p><h3 id=remove>remove</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-erlang data-lang=erlang><span style=color:#a6e22e>remove</span>(Id, Element, ORSet <span style=color:#f92672>=</span> #vorsetg{removes <span style=color:#f92672>=</span> Removes}) <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>
    CurrentExisting <span style=color:#f92672>=</span> [Elem || Elem <span style=color:#f92672>=</span> {_, E1} <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span> raw_value(ORSet),
                               E1 <span style=color:#f92672>=:=</span> Element],
    Removes1 <span style=color:#f92672>=</span> lists:<span style=color:#a6e22e>foldl</span>(<span style=color:#66d9ef>fun</span>(R, Rs) <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>
                                   rot:<span style=color:#a6e22e>add</span>({Id, R}, Rs)
                           <span style=color:#66d9ef>end</span>, Removes, CurrentExisting),
    ORSet#vorsetg{removes <span style=color:#f92672>=</span> Removes1}.

</code></pre></div><p><code>Id</code> defaults to a the current time in nanoseconds since it's precise enough for most cases, but can be given any value that provides timed order. Line 2 and 3 collect all observed and not yet removed instances of the element to delete, we then fold over those instances and add each of them to the ROT.</p><h3 id=gc>GC</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-erlang data-lang=erlang><span style=color:#a6e22e>gc</span>(HashID,
   #vorsetg{
      adds <span style=color:#f92672>=</span> Adds,
      removes <span style=color:#f92672>=</span> Removes,
      gced <span style=color:#f92672>=</span> GCed}) <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>
    {Values, Removes1} <span style=color:#f92672>=</span> rot:<span style=color:#a6e22e>remove</span>(HashID, Removes),
    Values1 <span style=color:#f92672>=</span> [V || {_, V} <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span> Values],
    Values2 <span style=color:#f92672>=</span> ordsets:<span style=color:#a6e22e>from_list</span>(Values1),
    #vorsetg{adds <span style=color:#f92672>=</span> ordsets:<span style=color:#a6e22e>subtract</span>(Adds, Values2),
             gced <span style=color:#f92672>=</span> ordsets:<span style=color:#a6e22e>add_element</span>(HashID, GCed),
             removes <span style=color:#f92672>=</span> Removes1}.
</code></pre></div><p>To GC the set we take the <code>HashID</code>, this is what the rot returns when it reports full buckets, and in line 6 remove it from the ROT. Thankfully the ROT will return the content of the deleted bucket, this comes in very handy, since in the process of garbage collecting the bucket we also need to remove the items once and for all from the add list as seen in line 9. We then record the GC action in line 10 to make sure it will applied during a merge.</p><p>Please note that currently this set, even so it is garbage collected still grows without bounds since the GC actions themselves are not (yet) garbage collected, this will be added in a later iteration.</p><h3 id=merge>merge</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-erlang data-lang=erlang><span style=color:#a6e22e>merge</span>(ROTA <span style=color:#f92672>=</span> #vorsetg{gced <span style=color:#f92672>=</span> GCedA},
      ROTB <span style=color:#f92672>=</span> #vorsetg{gced <span style=color:#f92672>=</span> GCedB}) <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>
    #vorsetg{
       adds <span style=color:#f92672>=</span> AddsA,
       gced <span style=color:#f92672>=</span> GCed,
       removes <span style=color:#f92672>=</span> RemovesA}
        <span style=color:#f92672>=</span> lists:<span style=color:#a6e22e>foldl</span>(<span style=color:#66d9ef>fun</span> gc<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>, ROTA, GCedB),
    #vorsetg{
       adds <span style=color:#f92672>=</span> AddsB,
       removes <span style=color:#f92672>=</span> RemovesB}
        <span style=color:#f92672>=</span> lists:<span style=color:#a6e22e>foldl</span>(<span style=color:#66d9ef>fun</span> gc<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>, ROTB, GCedA),
    ROT1 <span style=color:#f92672>=</span> rot:<span style=color:#a6e22e>merge</span>(RemovesA, RemovesB),
    #vorsetg{adds <span style=color:#f92672>=</span> ordsets:<span style=color:#a6e22e>union</span>(AddsA, AddsB),
             gced <span style=color:#f92672>=</span> GCed,
             removes <span style=color:#f92672>=</span> ROT1}.
</code></pre></div><p>Merging gets a bit more complicated due to the fact that we now have to take into account that values might be garbage collected in one set but not in the other. While merging them would do no harm it would recreate the garbage which isn't too nice. So what we do is applying the recorded GC actions to both sets first as seen in line 3 to 11 and then merge the remove values (line 12) finally the add values (line 13).</p><h2 id=results>Results</h2><p>I set up some proper tests for the implementation, comparing the GCed OR Set (bucket size 10) with a normal OR Set, running 1000 iterations with a set of 1000 instructions composed of 70% adds and removes, 20% merges and 10% GC events. T100 is a sliding time from the allowed collection of events older then the last merge.</p><p>Each stored element had the size of between 500 and 600 bytes (so there were 100 possible elements). A remove will always remove the stalest element, since they are added in random order this equals a random remove.</p><p>The operations are carried out of replicas copies of the set where add, and remove have a equal chance to be either happening just on copy A, or just on copy B, or on both replicas at the some time. GC operations are always carried out on both replicas but it should be noted that the GC operation does not include a merge operation so can be considered asynchronous.</p><p>All operations but the GC operation are executed exactly the same on the GCed OR set and the not GCed or Set in the same order and same spread.</p><p>At the end a final merge was performed and the resulting values compared for each iteration, no additional GC action takes place at the end.</p><p>Measured were both the space reduction per GC run and the final difference of size. Per GC run about 15% space was reclaimed and at the end the GCed set had a total space consumption of around 26% of the normal OR Set in average, 6% in the best and 143% in the worst case.</p><pre><code>src/vorsetg.erl:389:&lt;0.135.0&gt;: [Size] Cnt: 1000,   Avg: 0.261,  Min: 0.062, Max: 1.507
src/vorsetg.erl:389:&lt;0.135.0&gt;: [ RS ] Cnt: 49221,  Avg: 0.866,  Min: 0.064, Max: 1.0
src/vorsetg.erl:389:&lt;0.135.0&gt;: [ GC ] Cnt: 49221,  Avg: 55.870, Min: 0,     Max: 6483
src/vorsetg.erl:389:&lt;0.135.0&gt;: [ MG ] Cnt: 98357,  Avg: 58.110, Min: 0,     Max: 6596
src/vorsetg.erl:389:&lt;0.135.0&gt;: [ OP ] Cnt: 344708, Avg: 38.539, Min: 0,     Max: 6916```
</code></pre><p>The numbers are from a test run, for readability truncated manually after 3 digest and aligned to be nicer readable. <strong>Size</strong> is total size at the end of the iteration, <strong>RS</strong> is the space reduction per GC run. <strong>GC</strong>, <strong>MG</strong> and <strong>OP</strong> are the time used for garbage collection, merging and other operations respectively, the numbers are per execution and measured microseconds. Time measurements also include noise that from additional operations required for the test and should not be seen as a useful benchmark!</p><h2 id=conclusion>Conclusion</h2><p>The GC method described seems to work, and not even too badly, in the course of experimenting with values it showed that the conserved space is heavily dependant on the environment like the bucket size chosen, the size of the elements, the add/remove ratio and the ratio on which merges happen.</p><p>The OR Set it was compared with was not optimised at all, but thanks to it's simplicity a rather good candidate, the gains on already optimised sets will likely be lower. (run with a <a href=https://github.com/Licenser/ecrdt/blob/master/src/vorset2.erl>optimised OR Set</a> gave only 1 54% reduction in space instead of a 74% one with a normal OR Set).</p><p>The downside is that garbage collection takes time, so does merging, so a structure like this is over all slower then a not garbage collected version</p><hr><footer><section><h4>Share</h4><nav class="nav sharing-icons"><a class=nav-item href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.licenser.net%2f2013%2f06%2fa-asynchronously-gced-or-set%2f" title="Share on Facebook"><span class="fab fa-facebook-f fa-2x" aria-hidden=true></span></a><a class=nav-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.licenser.net%2f2013%2f06%2fa-asynchronously-gced-or-set%2f" title="Share on LinkedIn"><span class="fab fa-linkedin-in fa-2x" aria-hidden=true></span></a><a class=nav-item href="https://twitter.com/intent/tweet?url=https%3a%2f%2fblog.licenser.net%2f2013%2f06%2fa-asynchronously-gced-or-set%2f&text=A%20asynchronously%20GCed%20OR%20Set" title="Tweet this"><span class="fab fa-twitter fa-2x"></span></a></nav></section></footer></article></div><aside class="col-sm-3 ml-auto blog-sidebar"><section class=sidebar-module><h4>Links</h4><ol class=list-unstyled><li><a href=https://github.com/Licenser>GitHub</a></li></ol></section></aside></div></div><footer class=blog-footer><p dir=auto>Blog template created by <a href=https://twitter.com/mdo>@mdo</a>, ported to Hugo by <a href=https://twitter.com/mralanorth>@mralanorth</a>.</p><p><a href=#>Back to top</a></p></footer></body></html>