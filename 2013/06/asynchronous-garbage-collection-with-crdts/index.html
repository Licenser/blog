<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:title" content="Asynchronous garbage collection with CRDTs"><meta property="og:description" content="So CRDTs are very very nice data structures awesome for eventual consistent applications like riak, or the components of Project-FiFo. So they have one big drawback, most of them collect garbage, and over time that can sum up to a lot making them pretty unpractical in many cases. Collecting this garbage is a bit tricky, since usually it means synchronising the data - which going back to the eventual consistent stuff prevents either A or P."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/"><meta property="article:published_time" content="2013-06-11T00:00:00+00:00"><meta property="article:modified_time" content="2013-06-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Asynchronous garbage collection with CRDTs"><meta name=twitter:description content="So CRDTs are very very nice data structures awesome for eventual consistent applications like riak, or the components of Project-FiFo. So they have one big drawback, most of them collect garbage, and over time that can sum up to a lot making them pretty unpractical in many cases. Collecting this garbage is a bit tricky, since usually it means synchronising the data - which going back to the eventual consistent stuff prevents either A or P."><meta name=generator content="Hugo 0.62.2"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Asynchronous garbage collection with CRDTs","url":"https:\/\/blog.licenser.net\/2013\/06\/asynchronous-garbage-collection-with-crdts\/","wordCount":"1416","datePublished":"2013-06-11T00:00:00+00:00","dateModified":"2013-06-11T00:00:00+00:00","author":{"@type":"Person","name":"Heinz N. Gies"},"keywords":"erlang"}</script><link rel=canonical href=https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/><title>Asynchronous garbage collection with CRDTs | Lice!</title><link href=https://blog.licenser.net/css/style.6da5c906cc7a8fbb93f31cd2316c5dbe3f19ac4aa6bfb066f1243045b8f6061e.css rel=stylesheet integrity="sha256-baXJBsx6j7uT8xzSMWxdvj8ZrEqmv7Bm8SQwRbj2Bh4=" crossorigin=anonymous><script defer src=https://blog.licenser.net/js/fontawesome.min.90e14c13cee52929ac33e1c21694a3cc95063a194eb22aad9f7976434e1a9125.js integrity="sha256-kOFME87lKSmsM+HCFpSjzJUGOhlOsiqtn3l2Q04akSU=" crossorigin=anonymous></script></head><body><div class=blog-masthead><div class=container><nav class="nav blog-nav"><a class=nav-link href=https://blog.licenser.net/>Home</a></nav></div></div><header class=blog-header><div class=container><h1 class=blog-title dir=auto><a href=https://blog.licenser.net/ rel=home>Lice!</a></h1><p class="lead blog-description" dir=auto>A collection of somewhat random thoughts.</p></div></header><div class=container><div class=row><div class="col-sm-8 blog-main"><article class=blog-post><header><h2 class=blog-post-title dir=auto><a href=https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/>Asynchronous garbage collection with CRDTs</a></h2><p class=blog-post-meta><time datetime=2013-06-11T00:00:00Z>2013-06-11</time> by Heinz N. Gies in
<span class="fas fa-tag" aria-hidden=true></span>&nbsp;<a href=/tags/erlang/ rel=tag>erlang</a></p></header><p>So CRDTs are very very nice data structures awesome for eventual consistent applications like riak, or the components of <a href=http://project-fifo.net>Project-FiFo</a>. So they have one big drawback, most of them collect garbage, and over time that can sum up to a lot making them pretty unpractical in many cases. Collecting this garbage is a bit tricky, since usually it means synchronising the data - which going back to the eventual consistent stuff prevents either A or P.</p><p>I want to outline some thoughts here how one could deal with this issue. As usual the idea here isn't without tradeoffs, it does impose certain constrains on the systems behaviour and does not fit every behaviour in exchange of allowing garbage to be disposed of without the need of synchronisation. Now then, lets dive right in.</p><h2 id=whats-that-trash>What's that trash?</h2><p>We start with understanding what the garbage is that sums up. To allow CRDTs to work the way we do, they need to store some kind of history or legend of how the current state (version/value) of the CRDT came to existence.</p><p>If we look at a OR Set for example the history of this set is stored by recording all elements ever added along with all elements ever deleted - elements are tagged to be unique too so adding 5, removing 5 and adding 5 again and removing that again, leaves not a data structure with 0 elements but one with 4. That said there are ways to optimise the OR Set bot lets ignore this for the sake of the example. We can't just store an empty list since we need to make sure that when another copy of the same set can recreate the steps even if it just missed one of the events.</p><p>Actually we could, if we would synchronise all copies, say hey Â¯from now on you all agree that the new <strong>baseline</strong> (this is bold since it will come up a few more times) is an empty set from now on. And doing that we would have garbage collected the OR Set, disposed of data that isn't directly relevant to the current state any more.</p><p>If we don't guarantee that all objects are garbage collected to the same state, we face a real issue, since the new baseline will cause quite some trouble since the partially applied effects will just be applied again and possibly cause them to be doubly applied. <strong>Or in short, partially applied GCing will cause the CRDT to stop functioning.</strong></p><h2 id=things-get-old>Things get old.</h2><p>Looking at the data that gathers and how it is distributed there is one observation to be made: the older a change in state is the more likely it is to be present in all replicas. It makes sense, with eventual consistency we say &lsquo;eventually&rsquo; our data will be the same everywhere, and the chances of &lsquo;eventual&rsquo; are growing the older the change is since it will get more chance to replicate. (mechanisms similar to riak's AAE greatly help here).</p><p><img src=/images/posts/2013-06-11-asynchronous-garbage-collection-with-crdts1.png alt="state distribution"></p><p>So generally there is a T100 from which point on older data is shared between all instances and by that no longer relevant if we could just garbage collect it. But we don't want synchronous operations, nor do we want partial garbage collection (since that rally would suck).</p><p>Back to state, we know which ones we want to garbage collect, lets say we record not only the state change but a timestamp, a simple non monotonic system timestamp, it's cheap to get. Keep in mind T100 is well in the past, so if the precision of the times taps is good enough to guarantee that a event at T0 can not travel back behind T100, it's OK if order between T0 and T99 changes all the time, we don't really care about that so lets store the state data in a way that helps us with this:</p><p>T0 [S0,S1, &mldr;, Sn] T100 [Sn+1, &mldr;, Sn+m]</p><h2 id=a-trash-bin>A trash bin</h2><p>But since it would really suck (I know I'm repeating myself) if we partially GC the data we want to be sure that we agree, so would could go and ask all the replicas for their old data (older then T100). Yet this approach has a problem, for once T100 will shift in the time we check, then this might be more data to move then we care for.</p><p>So lets use a trash bin, or multiple once order our data in them so you've some groups of old messages, bunched together which can be agreed on, no matter on the time moving and they are smaller portions. Something like this</p><p>&mldr; T100 [Sn+1, &mldr;, Sn+100] [Sn+101, &mldr;, Sn+200]&mldr;</p><p>So we just have to agree on some bucket to garbage collect, since so if there is another half full bucket now since T100 has moved since the agreement we don't really care about that. Thanks to the fact that operations are commutative we also can garbage collect in a non direct order, so it's not a biggie if we take just one bucket and not the oldest one.</p><p>We're still left with transmitting (in this example) 100 elements to delete and haven't solve the problem of partial garbage collection, but at least we're a good step closer, we've put the garbage in bins now that are much easier to handle then just on a huge pile.</p><h2 id=a-garbage-compactor>A garbage compactor</h2><p>Lets tackle the last two issues we do a little trick, instead of sending out the entire bucket we compress it, create a hash of it and send this back and forth, so instead of:</p><p>[Sn+1, &mldr;, Sn+100]</p><p>We tag this bucket with a hash (over it's content) and the newest timestamp of the first element. Since it's older then T100 we do not need to worry of it changing and recreating the hash, and we get something like this:</p><p>(hash, TSn+1)[Sn+1, &mldr;, Sn+100]</p><p>To agree on buckets to collect and to give the collect order we just need to send the hash and timestamp and an identifier, this is pretty little data to send forth and back. This solves the send much data problem, curiously it also helps a lot with the partial garbage collection status.</p><h2 id=a-schedule-for-garbage-collection>A schedule for garbage collection</h2><p>With only the buckets tag identifying it we can solve the partial collection issue, we just treat garbage collection as just another event, storing it and replaying it if it wasn't present in a old replica. So we gradually progress the baseline of a replica towards the common baseline somewhat like this:</p><p><img src=/images/posts/2013-06-11-asyncronous-garbage-collection-with-crdts2.png alt="gc graph"></p><p>Ideally we store the GC operations in a own list and since we can easier apply it then and guarantee that the GC events are synchronised and applied before other events.</p><p>That's it, and should be a somewhat working implementation of asynchronous garbage collection for CRTDs. But it's not perfect so lets take a look at the downsides before we end this.</p><h2 id=lets-be-honest-it-still-has-a-downside>Lets be honest, it still has a downside</h2><p>This concept of GCing does not come for free, the data structure required isn't entirely trivial so it will add overhead, even so the current <a href=https://github.com/Licenser/ecrdt/blob/master/src/rot.erl>implementation</a> is pretty cheap when adding the events in right order, wrong order will cause additional overhead because it might cause elements to shift around in the structure.</p><p>It requires events to be timestamped, even so there is no requirement for absolute order, this adds a constraint to messages and events that wasn't there before. Also this is additional work and space that is consumed.</p><p>We need to define a T100 for the system and guarantee it, and find a balance of choosing a big enough T100 to ensure it's correctness while keeping it small enough to not keep a huge tail of non garbage collected events. That said this can be mitigated slightly by using a dynamic T100 for example put record when a object was last written to all primary nodes.</p><p>If T100 isn't chooses correctly it might end up getting really messy! if a elements slips by T100 that wasn't there it could mean that the garbage collection is broken for quite some while or worst state gets inconsistent.</p><p>Bucket size is another matter, it needs to be chosen carefully to be big enough to not spam the system but small enough to not take ages to fill, a event passing T100 but not filling the bucket isn't doing much good.</p><p>This is just a crazy idea. I haven't tried this, implemented it or have a formal prove, it is based on common sense and my understanding on matters so it might just explode ;)</p><hr><footer><section><h4>Share</h4><nav class="nav sharing-icons"><a class=nav-item href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.licenser.net%2f2013%2f06%2fasynchronous-garbage-collection-with-crdts%2f" title="Share on Facebook"><span class="fab fa-facebook-f fa-2x" aria-hidden=true></span></a><a class=nav-item href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.licenser.net%2f2013%2f06%2fasynchronous-garbage-collection-with-crdts%2f" title="Share on LinkedIn"><span class="fab fa-linkedin-in fa-2x" aria-hidden=true></span></a><a class=nav-item href="https://twitter.com/intent/tweet?url=https%3a%2f%2fblog.licenser.net%2f2013%2f06%2fasynchronous-garbage-collection-with-crdts%2f&text=Asynchronous%20garbage%20collection%20with%20CRDTs" title="Tweet this"><span class="fab fa-twitter fa-2x"></span></a></nav></section><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"lice"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="col-sm-3 ml-auto blog-sidebar"><section class=sidebar-module><h4>Links</h4><ol class=list-unstyled><li><a href=https://github.com/Licenser>GitHub</a></li><li><a href=https://twitter.com/heinz_gies>Twitter</a></li><a rel=me href=https://mastodon.social/@heinz>Mastodon</a></ol></section></aside></div></div><footer class=blog-footer><p dir=auto>Blog template created by <a href=https://twitter.com/mdo>@mdo</a>, ported to Hugo by <a href=https://twitter.com/mralanorth>@mralanorth</a>.</p><p><a href=#>Back to top</a></p></footer></body></html>