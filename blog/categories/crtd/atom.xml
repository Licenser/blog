<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CRTD | Lice!]]></title>
  <link href="http://blog.licenser.net/blog/categories/crtd/atom.xml" rel="self"/>
  <link href="http://blog.licenser.net/"/>
  <updated>2020-01-11T21:55:59+01:00</updated>
  <id>http://blog.licenser.net/</id>
  <author>
    <name><![CDATA[Heinz N. 'Licenser' Gies]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Asynchronously GCed or Set]]></title>
    <link href="http://blog.licenser.net/blog/2013/06/13/a-asynchronous-gced-or-set/"/>
    <updated>2013-06-13T11:09:00+02:00</updated>
    <id>http://blog.licenser.net/blog/2013/06/13/a-asynchronous-gced-or-set</id>
    <content type="html"><![CDATA[<p>Following the <a href="/blog/2013/06/11/asyncronous-garbage-collection-with-crdts/">article about Asynchronous garbage collection with CRDTs</a> I experimented with <a href="https://github.com/Licenser/ecrdt/blob/master/src/vorsetg.erl">implementing the concept</a>. The OR Set is a very nice data structure for this  since it&rsquo;s rather simple and so is it&rsquo;s garbage!</p>

<p>To garbage collect the <a href="https://github.com/Licenser/ecrdt/blob/master/src/vorset.erl">OR Set</a> we do the following, we take some of the elements of the remove set, and delete them from both the add and the remove set - this way we save the space for them and generate a new baseline.</p>

<p>First step was to implement the data structure described to hold the collectable items, I call it a <a href="https://github.com/Licenser/ecrdt/blob/master/src/rot.erl">ROT</a> (Roughly Ordered Tree) it&rsquo;s a nice name for garbage related stuff ;) and it is treeish and mostly ordered.</p>

<p>The interface of the ROT is rather simple, Elements must be time tagged, in the form {Time, Element}. Where time must not be a clock, as long as the Erlang comparison operations work on it to give an order. Then it allows asking for full buckets, and removing buckets based on their hash value and newest message timestamp.</p>

<p>While the elements in a the OR set area already tagged with a timestamp, this timestamp records addition, not deletion so it would be misleading to use them since the ROT would think the remove happened when actually the addition happened and this would violate the rule that no event can travel back behind T<sub>100</sub>. As a result we&rsquo;ll have to double timestamp the removes - as in add a second when when it was removed.</p>

<p>So since the ROT has a very similar interface to a G Set (which implemented the remove set before) the change is trivial. <strong>Remove</strong>, <strong>GC</strong> and the <strong>merge</strong> function are more interesting.</p>

<h3>remove</h3>

<pre><code class="erlang">remove(Id, Element, ORSet = #vorsetg{removes = Removes}) -&gt;
    CurrentExisting = [Elem || Elem = {_, E1} &lt;- raw_value(ORSet),
                               E1 =:= Element],
    Removes1 = lists:foldl(fun(R, Rs) -&gt;
                                   rot:add({Id, R}, Rs)
                           end, Removes, CurrentExisting),
    ORSet#vorsetg{removes = Removes1}.
</code></pre>

<p><code>Id</code> defaults to a the current time in nanoseconds since it&rsquo;s precise enough for most cases, but can be given any value that provides timed order. Line 2 and 3 collect all observed and not yet removed instances of the element to delete, we then fold over those instances and add each of them to the ROT.</p>

<h3>GC</h3>

<pre><code class="erlang">gc(HashID,
   #vorsetg{
      adds = Adds,
      removes = Removes,
      gced = GCed}) -&gt;
    {Values, Removes1} = rot:remove(HashID, Removes),
    Values1 = [V || {_, V} &lt;- Values],
    Values2 = ordsets:from_list(Values1),
    #vorsetg{adds = ordsets:subtract(Adds, Values2),
             gced = ordsets:add_element(HashID, GCed),
             removes = Removes1}.
</code></pre>

<p>To GC the set we take the <code>HashID</code>, this is what the rot returns when it reports full buckets, and in line 6 remove it from the ROT. Thankfully the ROT will return the content of the deleted bucket, this comes in very handy, since in the process of garbage collecting the bucket we also need to remove the items once and for all from the add list as seen in line 9. We then record the GC action in line 10 to make sure it will applied during a merge.</p>

<p>Please note that currently this set, even so it is garbage collected still grows without bounds since the GC actions themselves are not (yet) garbage collected, this will be added in a later iteration.</p>

<h3>merge</h3>

<pre><code class="erlang">merge(ROTA = #vorsetg{gced = GCedA},
      ROTB = #vorsetg{gced = GCedB}) -&gt;
    #vorsetg{
       adds = AddsA,
       gced = GCed,
       removes = RemovesA}
        = lists:foldl(fun gc/2, ROTA, GCedB),
    #vorsetg{
       adds = AddsB,
       removes = RemovesB}
        = lists:foldl(fun gc/2, ROTB, GCedA),
    ROT1 = rot:merge(RemovesA, RemovesB),
    #vorsetg{adds = ordsets:union(AddsA, AddsB),
             gced = GCed,
             removes = ROT1}.
</code></pre>

<p>Merging gets a bit more complicated due to the fact that we now have to take into account that values might be garbage collected in one set but not in the other. While merging them would do no harm it would recreate the garbage which isn&rsquo;t too nice. So what we do is applying the recorded GC actions to both sets first as seen in line 3 to 11 and then merge the remove values (line 12) finally the add values (line 13).</p>

<h2>Results</h2>

<p>I set up some proper tests for the implementation, comparing the GCed OR Set (bucket size 10) with a normal OR Set, running 1000 iterations with a set of 1000 instructions composed of 70% adds and removes, 20% merges and 10% GC events. T<sub>100</sub> is a sliding time from the allowed collection of events older then the last merge.</p>

<p>Each stored element had the size of between 500 and 600 bytes (so there were 100 possible elements). A remove will always remove the stalest element, since they are added in random order this equals a random remove.</p>

<p>The operations are carried out of replicas copies of the set where add, and remove have a equal chance to be either happening just on copy A, or just on copy B, or on both replicas at the some time. GC operations are always carried out on both replicas but it should be noted that the GC operation does not include a merge operation so can be considered asynchronous.</p>

<p>All operations but the GC operation are executed exactly the same on the GCed OR set and the not GCed or Set in the same order and same spread.</p>

<p>At the end a final merge was performed and the resulting values compared for each iteration, no additional GC action takes place at the end.</p>

<p>Measured were both the space reduction per GC run and the final difference of size. Per GC run about 15% space was reclaimed and at the end the GCed set had a total space consumption of around 26% of the normal OR Set in average, 6% in the best and 143% in the worst case.</p>

<pre><code>src/vorsetg.erl:389:&lt;0.135.0&gt;: [Size] Cnt: 1000,   Avg: 0.261,  Min: 0.062, Max: 1.507
src/vorsetg.erl:389:&lt;0.135.0&gt;: [ RS ] Cnt: 49221,  Avg: 0.866,  Min: 0.064, Max: 1.0
src/vorsetg.erl:389:&lt;0.135.0&gt;: [ GC ] Cnt: 49221,  Avg: 55.870, Min: 0,     Max: 6483
src/vorsetg.erl:389:&lt;0.135.0&gt;: [ MG ] Cnt: 98357,  Avg: 58.110, Min: 0,     Max: 6596
src/vorsetg.erl:389:&lt;0.135.0&gt;: [ OP ] Cnt: 344708, Avg: 38.539, Min: 0,     Max: 6916```
</code></pre>

<p>The numbers are from a test run, for readability truncated manually after 3 digest and aligned to be nicer readable. <strong>Size</strong> is total size at the end of the iteration, <strong>RS</strong> is the space reduction per GC run. <strong>GC</strong>, <strong>MG</strong> and <strong>OP</strong> are the time used for garbage collection, merging and other operations respectively, the numbers are per execution and measured microseconds. Time measurements also include noise that from additional operations required for the test and should not be seen as a useful benchmark!</p>

<h2>Conclusion</h2>

<p>The GC method described seems to work, and not even too badly, in the course of experimenting with values it showed that the conserved space is heavily dependant on the environment like the bucket size chosen, the size of the elements, the add/remove ratio and the ratio on which merges happen.</p>

<p>The OR Set it was compared with was not optimised at all, but thanks to it&rsquo;s simplicity a rather good candidate, the gains on already optimised sets will likely be lower. (run with a <a href="https://github.com/Licenser/ecrdt/blob/master/src/vorset2.erl">optimised OR Set</a> gave only 1 54% reduction in space instead of a 74% one with a normal OR Set).</p>

<p>The downside is that garbage collection takes time, so does merging, so a structure like this is over all slower then a not garbage collected version</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asynchronous Garbage Collection With CRDTs]]></title>
    <link href="http://blog.licenser.net/blog/2013/06/11/asyncronous-garbage-collection-with-crdts/"/>
    <updated>2013-06-11T15:45:00+02:00</updated>
    <id>http://blog.licenser.net/blog/2013/06/11/asyncronous-garbage-collection-with-crdts</id>
    <content type="html"><![CDATA[<p>So CRDTs are very very nice data structures awesome for eventual consistent applications like riak, or the components of <a href="http://project-fifo.net">Project-FiFo</a>. So they have one big drawback, most of them collect garbage, and over time that can sum up to a lot making them pretty unpractical in many cases. Collecting this garbage is a bit tricky, since usually it means synchronising the data - which going back to the eventual consistent stuff prevents either A or P.</p>

<p>I want to outline some thoughts here how one could deal with this issue. As usual the idea here isn&rsquo;t without tradeoffs, it does impose certain constrains on the systems behaviour and does not fit every behaviour in exchange of allowing garbage to be disposed of without the need of synchronisation. Now then, lets dive right in.</p>

<h2>What&rsquo;s that trash?</h2>

<p>We start with understanding what the garbage is that sums up. To allow CRDTs to work the way we do, they need to store some kind of history or legend of how the current state (version/value) of the CRDT came to existence.</p>

<p>If we look at a OR Set for example the history of this set is stored by recording all elements ever added along with all elements ever deleted - elements are tagged to be unique too so adding 5, removing 5 and adding 5 again and removing that again, leaves not a data structure with 0 elements but one with 4. That said there are ways to optimise the OR Set bot lets ignore this for the sake of the example. We can&rsquo;t just store an empty list since we need to make sure that when another copy of the same set can recreate the steps even if it just missed one of the events.</p>

<p>Actually we could, if we would synchronise all copies, say hey Â¯from now on you all agree that the new <strong>baseline</strong> (this is bold since it will come up a few more times) is an empty set from now on. And  doing that we would have garbage collected the OR Set, disposed of data that isn&rsquo;t directly relevant to the current state any more.</p>

<p>If we don&rsquo;t guarantee that all objects are garbage collected to the same state, we face a real issue, since the new baseline will cause quite some trouble since the partially applied effects will just be applied again and possibly cause them to be doubly applied. <strong>Or in short, partially applied GCing will cause the CRDT to stop functioning.</strong></p>

<h2>Things get old.</h2>

<p>Looking at the data that gathers and how it is distributed there is one observation to be made: the older a change in state is the more likely it is to be present in all replicas. It makes sense, with eventual consistency we say &lsquo;eventually&rsquo; our data will be the same everywhere, and the chances of &lsquo;eventual&rsquo; are growing the older the change is since it will get more chance to replicate. (mechanisms similar to riak&rsquo;s AAE greatly help here).</p>

<p><img src="/images/posts/2013-06-11-asynchronous-garbage-collection-with-crdts1.png" alt="state distribution" /></p>

<p>So generally there is a T<sub>100</sub> from which point on older data is shared between all instances and by that no longer relevant if we could just garbage collect it. But we don&rsquo;t want synchronous operations, nor do we want partial garbage collection (since that rally would suck).</p>

<p>Back to state, we know which ones we want to garbage collect, lets say we record not only the state change but a timestamp, a simple non monotonic system timestamp, it&rsquo;s cheap to get. Keep in  mind T<sub>100</sub> is well in the past, so if the precision of the times taps is good enough to guarantee that a event at T<sub>0</sub> can not travel back behind T<sub>100</sub>, it&rsquo;s OK if order between T<sub>0</sub> and T<sub>99</sub> changes all the time, we don&rsquo;t really care about that so lets store the state data in a way that helps us with this:</p>

<p>T<sub>0</sub> [S<sub>0</sub>,S<sub>1</sub>, &hellip;, S<sub>n</sub>] T<sub>100</sub> [S<sub>n+1</sub>, &hellip;, S<sub>n+m</sub>]</p>

<h2>A trash bin</h2>

<p>But since it would really suck (I know I&rsquo;m repeating myself) if we partially GC the data we want to be sure that we agree, so would could go and ask all the replicas for their old data (older then T<sub>100</sub>). Yet this approach has a problem, for once T<sub>100</sub> will shift in the time we check, then this might be more data to move then we care for.</p>

<p>So lets use a trash bin, or multiple once order our data in them so you&rsquo;ve some groups of old messages, bunched together which can be agreed on, no matter on the time moving and they are smaller portions. Something like this</p>

<p>&hellip; T<sub>100</sub> [S<sub>n+1</sub>, &hellip;, S<sub>n+100</sub>] [S<sub>n+101</sub>, &hellip;, S<sub>n+200</sub>]&hellip;</p>

<p>So we just have to agree on some bucket to garbage collect, since so if there is another half full bucket now since T<sub>100</sub> has moved since the agreement we don&rsquo;t really care about that. Thanks to the fact that operations are commutative we also can garbage collect in a non direct order, so it&rsquo;s not a biggie if we take just one bucket and not the oldest one.</p>

<p>We&rsquo;re still left with transmitting (in this example) 100 elements to delete and haven&rsquo;t solve the problem of partial garbage collection, but at least we&rsquo;re a good step closer, we&rsquo;ve put the garbage in bins now that are much easier to handle then just on a huge pile.</p>

<h2>A garbage compactor</h2>

<p>Lets tackle the last two issues we do a little trick, instead of sending out the entire bucket we compress it, create a hash of it and send this back and forth, so instead of:</p>

<p>[S<sub>n+1</sub>, &hellip;, S<sub>n+100</sub>]</p>

<p>We tag this bucket with a hash (over it&rsquo;s content) and the newest timestamp of the first element. Since it&rsquo;s older then T<sub>100</sub> we do not need to worry of it changing and recreating the hash, and we get something like this:</p>

<p>(hash, T<sub>S<sub>n+1</sub></sub>)[S<sub>n+1</sub>, &hellip;, S<sub>n+100</sub>]</p>

<p>To agree on buckets to collect and to give the collect order we just need to send the hash and timestamp and an identifier, this is pretty little data to send forth and back. This solves the send much data problem, curiously it also helps a lot with the partial garbage collection status.</p>

<h2>A schedule for garbage collection</h2>

<p>With only the buckets tag identifying it we can solve the partial collection issue, we just treat garbage collection as just another event, storing it and replaying it if it wasn&rsquo;t present in a old replica. So we gradually progress the baseline of a replica towards the common baseline somewhat like this:</p>

<p><img src="/images/posts/2013-06-11-asyncronous-garbage-collection-with-crdts2.png" alt="gc graph" /></p>

<p>Ideally we store the GC operations in a own list and since we can easier apply it then and guarantee that the GC events are synchronised and applied before other events.</p>

<p>That&rsquo;s it, and should be a somewhat working implementation of asynchronous garbage collection for CRTDs. But it&rsquo;s not perfect so lets take a look at the downsides before we end this.</p>

<h2>Lets be honest, it still has a downside</h2>

<p>This concept of GCing does not come for free, the data structure required isn&rsquo;t entirely trivial so it will add overhead, even so the current <a href="https://github.com/Licenser/ecrdt/blob/master/src/rot.erl">implementation</a> is pretty cheap when adding the events in right order, wrong order will cause additional overhead because it might cause elements to shift around in the structure.</p>

<p>It requires events to be timestamped, even so there is no requirement for absolute order, this adds a constraint to messages and events that wasn&rsquo;t there before. Also this is additional work and space that is consumed.</p>

<p>We need to define a T<sub>100</sub> for the system and guarantee it, and find a balance of choosing a big enough T<sub>100</sub> to ensure it&rsquo;s correctness while keeping it small enough to not keep a huge tail of non garbage collected events. That said this can be mitigated slightly by using a dynamic T<sub>100</sub> for example put record when a object was last written to all primary nodes.</p>

<p>If T<sub>100</sub> isn&rsquo;t chooses correctly it might end up getting really messy! if a elements slips by T<sub>100</sub> that wasn&rsquo;t there it could mean that the garbage collection is broken for quite some while or worst state gets inconsistent.</p>

<p>Bucket size is another matter, it needs to be chosen carefully to be big enough to not spam the system but small enough to not take ages to fill, a event passing T<sub>100</sub> but not filling the bucket isn&rsquo;t doing much good.</p>

<p>This is just a crazy idea. I haven&rsquo;t tried this, implemented it or have a formal prove, it is based on common sense and my understanding on matters so it might just explode ;)</p>
]]></content>
  </entry>
  
</feed>
