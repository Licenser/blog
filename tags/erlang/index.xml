<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>erlang on Lice!</title><link>https://blog.licenser.net/tags/erlang/</link><description>Recent content in erlang on Lice!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 10 Jul 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.licenser.net/tags/erlang/index.xml" rel="self" type="application/rss+xml"/><item><title>migrating to rebar3</title><link>https://blog.licenser.net/2015/07/migrating-to-rebar3/</link><pubDate>Fri, 10 Jul 2015 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2015/07/migrating-to-rebar3/</guid><description>A long journey from rebar2 to rebar3 Rebar 3 has recently started to surface out of alpha state and entered beta1, about time for the crazy people like me to abandon tried and tested tools to venture into the great vastness of the unknown!
So with a backpack, hiking shoes, food for about a week and a direct line to the rebar3 IRC channel I set off to migrate sniffle from rebar2 to rebar3.</description></item><item><title>A asynchronously GCed OR Set</title><link>https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/</link><pubDate>Thu, 13 Jun 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/</guid><description>Following the article about Asynchronous garbage collection with CRDTs I experimented with implementing the concept. The OR Set is a very nice data structure for this since it's rather simple and so is it's garbage!
To garbage collect the OR Set we do the following, we take some of the elements of the remove set, and delete them from both the add and the remove set - this way we save the space for them and generate a new baseline.</description></item><item><title>Asynchronous garbage collection with CRDTs</title><link>https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/</link><pubDate>Tue, 11 Jun 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/</guid><description>So CRDTs are very very nice data structures awesome for eventual consistent applications like riak, or the components of Project-FiFo. So they have one big drawback, most of them collect garbage, and over time that can sum up to a lot making them pretty unpractical in many cases. Collecting this garbage is a bit tricky, since usually it means synchronising the data - which going back to the eventual consistent stuff prevents either A or P.</description></item></channel></rss>