<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>erlang on Lice!</title><link>https://blog.licenser.net/tags/erlang/</link><description>Recent content in erlang on Lice!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 13 Jun 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.licenser.net/tags/erlang/index.xml" rel="self" type="application/rss+xml"/><item><title>A asynchronously GCed OR Set</title><link>https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/</link><pubDate>Thu, 13 Jun 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/</guid><description>Following the article about Asynchronous garbage collection with CRDTs I experimented with implementing the concept. The OR Set is a very nice data structure for this since it's rather simple and so is it's garbage!
To garbage collect the OR Set we do the following, we take some of the elements of the remove set, and delete them from both the add and the remove set - this way we save the space for them and generate a new baseline.</description></item><item><title>Asynchronous garbage collection with CRDTs</title><link>https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/</link><pubDate>Tue, 11 Jun 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/</guid><description>So CRDTs are very very nice data structures awesome for eventual consistent applications like riak, or the components of Project-FiFo. So they have one big drawback, most of them collect garbage, and over time that can sum up to a lot making them pretty unpractical in many cases. Collecting this garbage is a bit tricky, since usually it means synchronising the data - which going back to the eventual consistent stuff prevents either A or P.</description></item></channel></rss>