<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lice!</title><link>https://blog.licenser.net/</link><description>Recent content on Lice!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 11 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.licenser.net/index.xml" rel="self" type="application/rss+xml"/><item><title>Multithreaded rust on Threadripper</title><link>https://blog.licenser.net/2020/01/multithreaded-rust-on-threadripper/</link><pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2020/01/multithreaded-rust-on-threadripper/</guid><description>I recently ran some benchmarks on a Threadripper 3960X system and the results were surprising me quite a bit. Simplified, the throughput the benchmark recorded went down, from 341 MB/s on a MBP to 136 MB/s on a Threadripper desktop. Prior I had read Daniel Lemire's notes on the sub optimal performance for simdjson on Zen 2, which is heavily used in the benchmark, but the suggested drop were a few percent not half.</description></item><item><title>Dell XPS/Windows as a dev env</title><link>https://blog.licenser.net/2018/05/dell-xps/windows-as-a-dev-env/</link><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2018/05/dell-xps/windows-as-a-dev-env/</guid><description>I've recently gotten a Dell XPS 15&amp;rdquo; 2-in-1 and started using it as a development environment for the last week. To be honest as a long term MacBook user I expected a rather disapointing experience but to my big surprise I do really like it so far. But enough of a preamble. Why I'm writing this? Because I figured that the mistakes I made, the hints I got all over the place would have really helped me if someone had collected them - so I do that now.</description></item><item><title>migrating to rebar3</title><link>https://blog.licenser.net/2015/07/migrating-to-rebar3/</link><pubDate>Fri, 10 Jul 2015 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2015/07/migrating-to-rebar3/</guid><description>A long journey from rebar2 to rebar3 Rebar 3 has recently started to surface out of alpha state and entered beta1, about time for the crazy people like me to abandon tried and tested tools to venture into the great vastness of the unknown!
So with a backpack, hiking shoes, food for about a week and a direct line to the rebar3 IRC channel I set off to migrate sniffle from rebar2 to rebar3.</description></item><item><title>Postmortem of a interesting bug</title><link>https://blog.licenser.net/2014/11/postmortem-of-a-interesting-bug/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2014/11/postmortem-of-a-interesting-bug/</guid><description>Symptoms After a full network outage in a larger system (7 FiFo instances and, a few dozen of hypervisors, VM's in the 3 digit number) a small percentage of the VM's stored in FiFo lost information which package was assigned to them and which organization they belong to.
Technical background As part of planned maintenance on the switching layer the entire network was taken down. Effectively cutting the communication between any two systems in the network.</description></item><item><title>Post-mortem of a failed support case.</title><link>https://blog.licenser.net/2014/02/post-mortem-of-a-failed-support-case./</link><pubDate>Sat, 01 Feb 2014 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2014/02/post-mortem-of-a-failed-support-case./</guid><description>Every now and then I check the link reports for Project FiFo to see what people think and write about it. Recently I stumbled about an article that oddly enough made me both proud and sad. It actually was a rather negative one, which is a shame, but on the other hand a project isn't mature until people care enough to complain.
Yet even so it would be very easy to cast this aside as a &amp;lsquo;success&amp;rsquo; in a strange manner, it still bothers me that someone is upset enough with FiFo to spend his time writing a longish blog article and write their own management software.</description></item><item><title>Backups with Project FiFo</title><link>https://blog.licenser.net/2014/01/backups-with-project-fifo/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2014/01/backups-with-project-fifo/</guid><description>With 0.4.3 FiFo introduces support for LeoFS and this allows for some quite nice new features. Most importantly it decouples FiFo's operations from storing big amounts of data which makes maintaining either of this much more sensible and scaling storage much more easy.
Then again while nice that is not the important part, just storing datasets somewhere else does not make much of a difference for most users but what LoeFS allows FiFo to store much more data then would be good in the old setup.</description></item><item><title>A asynchronously GCed OR Set</title><link>https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/</link><pubDate>Thu, 13 Jun 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/06/a-asynchronously-gced-or-set/</guid><description>Following the article about Asynchronous garbage collection with CRDTs I experimented with implementing the concept. The OR Set is a very nice data structure for this since it's rather simple and so is it's garbage!
To garbage collect the OR Set we do the following, we take some of the elements of the remove set, and delete them from both the add and the remove set - this way we save the space for them and generate a new baseline.</description></item><item><title>Asynchronous garbage collection with CRDTs</title><link>https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/</link><pubDate>Tue, 11 Jun 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/06/asynchronous-garbage-collection-with-crdts/</guid><description>So CRDTs are very very nice data structures awesome for eventual consistent applications like riak, or the components of Project-FiFo. So they have one big drawback, most of them collect garbage, and over time that can sum up to a lot making them pretty unpractical in many cases. Collecting this garbage is a bit tricky, since usually it means synchronising the data - which going back to the eventual consistent stuff prevents either A or P.</description></item><item><title>Happy birthday Project FiFo</title><link>https://blog.licenser.net/2013/05/happy-birthday-project-fifo/</link><pubDate>Mon, 06 May 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/05/happy-birthday-project-fifo/</guid><description>Some might know it, some might not and some might not care but for what it's worth I'm the author of Project-FiFo (or most of it) and today is Project-FiFo's first birthday (since the domain registration) and I want to take this chance to look back to the past year and reflect, say thank you to all of you and take a look in the future.
When I started Project FiFo a year ago it was more of a tiny hobby project and I could have sworn it would stand in row with all the other little open source projects no one would ever give a damn about.</description></item><item><title>FiFo + 80LOC of bash = 5 node riak cluster</title><link>https://blog.licenser.net/2013/04/fifo-80loc-of-bash-5-node-riak-cluster/</link><pubDate>Tue, 23 Apr 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/04/fifo-80loc-of-bash-5-node-riak-cluster/</guid><description>The reason The question &amp;lsquo;why would I want at least 5 nodes&amp;rsquo; comes up very often in the #riak IRC channel, there is a good explanation. But that's boring, no one likes reading manuals, we, as engineers, like to try things out (aka. break stuff).
Only downside with that is that we need to set things up before we can break them, or even worst need to un-break it later to try out different things (aka.</description></item><item><title>Writing your first riak test test (yes I know there are two tests there)</title><link>https://blog.licenser.net/2013/04/writing-your-first-riak-test-test-yes-i-know-there-are-two-tests-there/</link><pubDate>Tue, 09 Apr 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/04/writing-your-first-riak-test-test-yes-i-know-there-are-two-tests-there/</guid><description>As promised in a previous post I'll talk a bit about writing tests for riak_test. To start with the obvious it's pretty simple and pretty awesome. riak_test gives you the tools you've dreamed of when testing distributed riak_core applications:
a backchannel to communicate and execute commands on the nodes. a nice and way to bring up and tear down the test environment. helper functions to deal with the riak_core cluster.</description></item><item><title>Getting started with riak_test and riak_core</title><link>https://blog.licenser.net/2013/03/getting-started-with-riak_test-and-riak_core/</link><pubDate>Sun, 31 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/03/getting-started-with-riak_test-and-riak_core/</guid><description>If you don't know what riak_core is, or don't have a riak_core based application you'll probably not take too much practical use of this posts you might want to start with Ryan Zezeski's &amp;ldquo;working&amp;rdquo; blog try try try and the rebar plugin.
That said if you have a riak_core app this posts should get you started on how to test it with riak_test. We'll not go through the topic of how to write the tests itself, this might come in a later post also the riak_kv tests are a good point to start.</description></item><item><title>Plugins with Erlang</title><link>https://blog.licenser.net/2013/03/plugins-with-erlang/</link><pubDate>Tue, 19 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/03/plugins-with-erlang/</guid><description>Preamble Lets start with this, Erlang releases are super useful they are one of the features I like most about Erlang - you get out an entirely self contained package you can deploy and forget, no library trouble, no wrong version of the VM no trouble at all.
BUT (this had to come didn't it) sometimes they are limiting and kind of inflexible, adding a tiny little feature means rolling out a new release, with automated builds that is not so bad but &amp;lsquo;not so bad&amp;rsquo; isn't good either.</description></item><item><title>A vow to create tickets</title><link>https://blog.licenser.net/2013/01/a-vow-to-create-tickets/</link><pubDate>Thu, 31 Jan 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/01/a-vow-to-create-tickets/</guid><description>I've had some open source projects before, actually quite some, but Project FiFo is by far the most successful one. And aside from the technical perspective I've learned a tremendous amount of new things already, one of which I want so share since. It sounds simple but I never looked at it this way before: Tickets.
The project has caught on momentum so fast that at &amp;lsquo;rush hours&amp;rsquo; people come with questions, bug reports and feature requests at rate that it's they pile up faster then we can help or answer, the channel and community already does a great job &amp;lsquo;filtering&amp;rsquo; out easy to answer topics but enough are complicated to a point where a developer has to look at them.</description></item><item><title>Erlang and more DTrace</title><link>https://blog.licenser.net/2013/01/erlang-and-more-dtrace/</link><pubDate>Mon, 28 Jan 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/01/erlang-and-more-dtrace/</guid><description>Some nice additions to the little Erlang DTrace demo. For once I've added a filed to input custom scripts which are run on the server which is pretty neat since it allows running all kind of (l)quantize based scripts from the server and get a nice heatmap.
Like how about the heatmap of how Erlang function call times?
The script used (also included in the repository):
erlang*:::global-function-entry { self-&amp;gt;funcall_entry_ts[copyinstr(arg1)] = vtimestamp; } erlang*:::function-return { @time[copyinstr(arg1)] = lquantize((vtimestamp - self-&amp;gt;funcall_entry_ts[copyinstr(arg1)] ) / 1000, 0, 63, 2); } Now that is already cool but there is more, in addition to there is a page now that allows to show list based queries (as count or sum) so for example it would be very easy to get a profiling of an Erlang program like this:</description></item><item><title>Erlang and DTrace</title><link>https://blog.licenser.net/2013/01/erlang-and-dtrace/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/01/erlang-and-dtrace/</guid><description>As part of Project FiFo I've invested some time to research into DTrace and Erlang, not the probes that are there since some time but a DTrace consumer - letting you execute DTrace scripts from within Erlang and read the results.
The result of this research is the erltrace a consumer for DTrace implemented as a Erlang NIF. The NIF is based on the node.js and and python implementations - many thanks to them!</description></item><item><title>A new start</title><link>https://blog.licenser.net/2013/01/a-new-start/</link><pubDate>Thu, 24 Jan 2013 00:00:00 +0000</pubDate><guid>https://blog.licenser.net/2013/01/a-new-start/</guid><description>Now it has been a while, it's surprisingly hard to find a decent way to blog in the end I landed with Octopress. Lets see how that turns out, so far after a slightly bumpy bumpy start it seems decent enough.</description></item></channel></rss>